# 算法基础

## 基础算法

### 快速排序

#### 快速排序

分治的思想

![1602939188864](1602939188864.png)

1、确定分界点x， f[l]， f[(l + r)/2]， f[r]

2、调整区间（左边所有数Left <= x，右边所有数 Right>= x）

![1602939200618](1602939200618.png)

3、递归处理左右两端

**暴力做法**：会浪费空间，时间复杂度不变

![1603518939940](1603518939940.png)

**题目描述**

给定你一个长度为n的整数数列。

请你使用快速排序对这个数列按照从小到大进行排序。

并将排好序的数列按顺序输出。

**输入格式**

输入共两行，第一行包含整数 n。

第二行包含 n 个整数（所有整数均在1~109109范围内），表示整个数列。

**输出格式**

输出共一行，包含 n 个整数，表示排好序的数列。

**数据范围**

1≤n≤1000001≤n≤100000

**输入样例：**

```
5
3 1 2 4 5
```

**输出样例：**

```
1 2 3 4 5
```

```c++
#include<iostream>
#include<cstring>

using namespace std;

const int N = 1e6 + 10;
int n;
int q[N]; 
//数据量大建议用scanf读入数据 

//快排模板 
void quick_sort(int q[],int l,int r)
{
	int x = q[(r + l) / 2], i = l - 1, j = r + 1; //x取值是任意的，也可以选择中点。i，j指向真正的边界 
	if(l >= r) return;
	while(i < j)
	{
		do i++; while(q[i] < x);
		do j--; while(q[j] > x);
		if(i < j) swap(q[i],q[j]);
	 } 
	 
	 quick_sort(q,l,j);
	 quick_sort(q,j + 1,r);
}

int main()
{
	scanf("%d",&n);
	for(int i = 0; i < n; i++) scanf("%d", &q[i]);
//	for(int i = 0; i < n; i++) printf("%d ", q[i]);
	quick_sort(q,0,n-1);
	for(int i = 0; i < n; i++) printf("%d ", q[i]);
	return 0;
}
```

#### 第k个数--快速选择算法

**题目描述**

给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。

**输入格式**

第一行包含两个整数 n 和 k。

第二行包含 n 个整数（所有整数均在1~109109范围内），表示整数数列。

**输出格式**

输出一个整数，表示数列的第k小数。

**数据范围**

1≤n≤1000001≤n≤100000,
1≤k≤n1≤k≤n

**输入样例：**

```
5 3
2 4 1 5 3
```

**输出样例：**

```
3
```

**解题思路：**

![1603590857428](1603590857428.png)

时间复杂度：$n(1+1/2+1/4+1/8+....) <= 2n$   O(n)

```c++
//先快速排序再去查找，时间复杂度为nlog(n)
//局部变量和全局变量重名时优先局部
// #include<iostream>

// using namespace std;

// const int N = 100000;
// int q[N];
// int n;
// int k;

// void quick_sort(int q[], int l, int r)
// {
// 	int x = q[(l + r) / 2], i = l - 1, j = r + 1;
	
// 	if(l >= r) return;
	
// 	while(i < j)
// 	{
// 		do i++; while(q[i] < x);
// 		do j--; while(q[j] > x);
// 		if(i < j) swap(q[i],q[j]);	
// 	}
	
	
// 	quick_sort(q,l,j);
// 	quick_sort(q,j+1,r);
// }

// int main()
// {
// 	cin >> n >> k;
// 	for(int i = 0; i < n; i++) scanf("%d",&q[i]);
// 	quick_sort(q, 0, n-1);
	
// 	cout << q[k - 1];
	
// }


#include<iostream>

using namespace std;

const int N = 100010;
int n;
int k;
int q[N];

int quick_sort(int l,int r,int k)
{
	int x = q[(l + r) / 2], i = l - 1, j = r + 1;
	
	if ( l == r ) return q[l];
	
	while(i < j)
	{
		while(q[ ++i] < x);
		while(q[ -- j] > x);
		
		if(i < j) swap(q[i],q[j]);
	}
	
	int sl = j - l + 1;
	if(k <= sl) return quick_sort(l,j,k);
	
	return quick_sort(j+1,r,k-sl);
}

int main()
{
	cin >> n >> k;
	for(int i = 0; i < n; i++) scanf("%d",&q[i]);
	cout << quick_sort(0 , n - 1 , k);
}
 
```

### 归并排序

#### 归并排序

思想：分治

![image-20201124154356625](D:\Github\MyNotes\算法基础\image-20201124154356625.png)

1. 确定分界点$min=(left+right)/2$
2. 递归排序left和right
3. 归并——合二为一

![image-20201124164059779](D:\Github\MyNotes\算法基础\image-20201124164059779.png)

时间复杂度$log^n$

模板：

```c++
//归并排序
#include<iostream>
#include<cstdio>

using namespace std;

const int N = 1000010;

int n;
int q[N], temp[N];

void merge_sort(int q[], int l, int r)
{
	if (l >= r) return;

	int mid = (l + r) / 2;

	merge_sort(q, l, mid);
	merge_sort(q, mid + 1, r);

	int k = 0, i = l, j = mid + 1;
	while (i <= mid && j <= r)
		if (q[i] < q[j]) temp[k++] = q[i++];
		else temp[k++] = q[j++];
	while (i <= mid) temp[k++] = q[i++];
	while (j <= r) temp[k++] = q[j++];

	for (i = l, j = 0; i <= r; i++, j++) q[i] = temp[j];
}

int main()
{
	scanf_s("%d", &n);
	for (int i = 0; i < n; i++) scanf_s("%d", &q[i]);

	merge_sort(q, 0, n - 1);

	for (int i = 0; i < n; i++) printf("%d ", q[i]);
	return 0;
}
```

